<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Note Taking App</title>
    <style>
        :root{--font-size:18px}
        html,body{height:100%;margin:0;font-family:ui-monospace, SFMono-Regular, Menlo, monospace;background:#0f1724;color:#e6edf3}
        .toolbar{position:fixed;right:12px;top:12px;display:flex;gap:8px;z-index:20}
        button{background:#122033;border:1px solid #243447;color:#cfe7ff;padding:6px 10px;border-radius:6px;cursor:pointer}
        button:hover{background:#1a2e3c}
        .editor{
            box-sizing:border-box;
            width:100%;
            min-height:100vh;
            padding:36px;
            outline:none;
            white-space:pre-wrap;
            word-break:break-word;
            font-size:var(--font-size);
            line-height:1.4;
            caret-color:#7ee3a2;
            background:linear-gradient(180deg,#071025 0%, #071025 60%, #061123 100%);
        }
        .editor img{max-width:100%;height:auto;margin:8px 0;border-radius:6px;display:block}
        /* Censored appearance */
        .censored{background:rgba(0,0,0,0.6);color:transparent;position:relative;border-radius:3px;padding:0 2px}
        .censored::after{content:'████';color:#e6edf3;position:absolute;left:0;top:0;right:0;bottom:0;display:block;padding:0 2px;pointer-events:none}
        .selected{outline:2px dashed rgba(126,227,162,0.6);outline-offset:4px}
        .placeholder{position:absolute;left:36px;top:36px;color:#8193a5;pointer-events:none;user-select:none}
        .container{position:relative;min-height:100vh}
        .small{font-size:14px}
        .auth{position:fixed;left:12px;top:12px;display:flex;gap:8px;align-items:center;z-index:30}
        .auth input{background:#0b1620;border:1px solid #243447;color:#cfe7ff;padding:6px;border-radius:6px}
        .auth .user{color:#9fe7b1}
    </style>
</head>
<body>
    <div class="toolbar">
        <button id="dec">A-</button>
        <button id="inc">A+</button>
        <button id="clear">Clear</button>
        <button id="download">Download .txt</button>
        <button id="censor-toggle">Censor/Uncensor</button>
        <button id="add-image">Add Image</button>
        <input type="file" id="image-input" accept="image/*" style="display:none;">
    </div>

    <div class="auth" id="auth">
        <input id="auth-username" placeholder="username" />
        <input id="auth-password" type="password" placeholder="password" />
        <button id="btn-login">Login</button>
        <button id="btn-register">Register</button>
        <span id="auth-user" class="user" style="display:none"></span>
        <button id="btn-logout" style="display:none">Logout</button>
    </div>

    <div class="container">
        <div id="placeholder" class="placeholder">Click here and start typing...</div>
        <div id="editor" class="editor" contenteditable="true" spellcheck="false" aria-label="typing area"></div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const placeholder = document.getElementById('placeholder');
        const root = document.documentElement;

        function updatePlaceholder() {
            placeholder.style.display = editor.textContent.trim().length ? 'none' : 'block';
        }

        editor.addEventListener('input', updatePlaceholder);
        editor.addEventListener('focus', updatePlaceholder);
        editor.addEventListener('blur', updatePlaceholder);

        // Focus when clicking placeholder or anywhere in container
        placeholder.addEventListener('click', ()=>{ editor.focus(); });

        // Font size controls
        document.getElementById('inc').addEventListener('click', ()=>{
            const cur = parseFloat(getComputedStyle(root).getPropertyValue('--font-size'));
            root.style.setProperty('--font-size', (cur+2)+'px');
        });
        document.getElementById('dec').addEventListener('click', ()=>{
            const cur = parseFloat(getComputedStyle(root).getPropertyValue('--font-size'));
            root.style.setProperty('--font-size', Math.max(10, cur-2)+'px');
        });

        // Clear content
        document.getElementById('clear').addEventListener('click', ()=>{
            if(confirm('Clear the editor?')) { editor.innerText = ''; updatePlaceholder(); editor.focus(); }
        });

        // Download as .txt
        document.getElementById('download').addEventListener('click', ()=>{
            const text = editor.innerText;
            const blob = new Blob([text], {type:'text/plain'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'notes.txt';
            a.click();
            URL.revokeObjectURL(a.href);
        });

        // Add image
        document.getElementById('add-image').addEventListener('click', ()=>{
            document.getElementById('image-input').click();
        });

        document.getElementById('image-input').addEventListener('change', (e)=>{
            const file = e.target.files[0];
            if(file){
                const reader = new FileReader();
                reader.onload = (event)=>{
                    const img = document.createElement('img');
                    img.src = event.target.result;
                    editor.appendChild(img);
                    editor.appendChild(document.createElement('br'));
                    editor.focus();
                };
                reader.readAsDataURL(file);
            }
        });

        // Censor / Uncensor selected text
        let currentCensoredNode = null;

        function clearCensorSelection(){
            if(currentCensoredNode && currentCensoredNode.classList){
                currentCensoredNode.classList.remove('selected');
            }
            currentCensoredNode = null;
        }

        function maskText(str){
            // replace visible characters with block glyphs but keep whitespace
            return str.replace(/\S/g, '█');
        }

        function censorSelection(){
            const sel = window.getSelection();
            if(!sel || !sel.rangeCount) return false;
            const range = sel.getRangeAt(0);
            if(range.collapsed) return false;
            // Extract contents and serialize original HTML
            const frag = range.extractContents();
            const wrapper = document.createElement('div');
            wrapper.appendChild(frag);
            const originalHTML = wrapper.innerHTML;
            const plain = wrapper.textContent || wrapper.innerText || '';

            const span = document.createElement('span');
            span.className = 'censored';
            span.contentEditable = 'false';
            span.dataset.original = originalHTML;
            span.dataset.plain = plain;
            // set masked visible text (keeps length/spacing roughly)
            span.textContent = maskText(plain);
            range.insertNode(span);
            sel.removeAllRanges();
            currentCensoredNode = span;
            span.classList.add('selected');
            return true;
        }

        function uncensorNode(node){
            if(!node) return;
            if(node.classList && node.classList.contains('censored')){
                const parent = node.parentNode;
                const tmp = document.createElement('div');
                tmp.innerHTML = node.dataset.original || node.textContent;
                // insert children in place
                while(tmp.firstChild) parent.insertBefore(tmp.firstChild, node);
                parent.removeChild(node);
            }
        }

        // Click inside editor: select censored span if clicked
        editor.addEventListener('click', (e)=>{
            clearCensorSelection();
            let t = e.target;
            if(t && t.nodeType === Node.TEXT_NODE) t = t.parentElement;
            if(t && t.classList && t.classList.contains('censored')){
                currentCensoredNode = t;
                t.classList.add('selected');
            }
        });

        // Clicking outside clears selection
        document.addEventListener('click', (e)=>{
            if(!editor.contains(e.target) && !e.target.closest('.toolbar')) clearCensorSelection();
        });

        // Toolbar button: censor selection if any, otherwise uncensor selected node
        document.getElementById('censor-toggle').addEventListener('click', ()=>{
            const sel = window.getSelection();
            if(sel && sel.rangeCount && !sel.getRangeAt(0).collapsed){
                if(censorSelection()){ updatePlaceholder(); editor.focus(); return; }
            }
            if(currentCensoredNode){
                uncensorNode(currentCensoredNode);
                currentCensoredNode = null;
            }
        });

        // Keyboard shortcut: Ctrl/Cmd+Shift+C to toggle censor
        window.addEventListener('keydown', (e)=>{
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase()==='c'){
                e.preventDefault(); document.getElementById('censor-toggle').click();
            }
        });

        // Shortcut: Ctrl/Cmd+S to download, Ctrl/Cmd+K to clear
        window.addEventListener('keydown', (e)=>{
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='s') {
                e.preventDefault(); document.getElementById('download').click();
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='k') {
                e.preventDefault(); document.getElementById('clear').click();
            }
        });

        // Auto-focus editor on load
        window.addEventListener('load', ()=>{ editor.focus(); updatePlaceholder(); });

        // --- Simple auth (register / login) ---
        const API_ROOT = 'http://localhost:5000/api';
        const tokenKey = 'auth_token';

        function setAuthToken(token){
            if(token) localStorage.setItem(tokenKey, token);
            else localStorage.removeItem(tokenKey);
        }

        function getAuthToken(){ return localStorage.getItem(tokenKey); }

        async function apiFetch(path, opts={}){
            const headers = opts.headers || {};
            const token = getAuthToken();
            if(token) headers['Authorization'] = 'Bearer '+token;
            const res = await fetch(API_ROOT+path, Object.assign({}, opts, { headers }));
            return res;
        }

        async function updateAuthUI(){
            const userSpan = document.getElementById('auth-user');
            const logoutBtn = document.getElementById('btn-logout');
            const loginBtn = document.getElementById('btn-login');
            const registerBtn = document.getElementById('btn-register');
            const usernameInput = document.getElementById('auth-username');
            const passwordInput = document.getElementById('auth-password');
            const token = getAuthToken();
            if(!token){
                userSpan.style.display = 'none';
                logoutBtn.style.display = 'none';
                loginBtn.style.display = '';
                registerBtn.style.display = '';
                usernameInput.style.display = '';
                passwordInput.style.display = '';
                return;
            }
            try{
                const r = await apiFetch('/me');
                if(!r.ok) throw new Error('not ok');
                const data = await r.json();
                userSpan.textContent = 'Signed in: '+data.username;
                userSpan.style.display = '';
                logoutBtn.style.display = '';
                loginBtn.style.display = 'none';
                registerBtn.style.display = 'none';
                usernameInput.style.display = 'none';
                passwordInput.style.display = 'none';
            }catch(e){
                // invalid token
                setAuthToken(null);
                userSpan.style.display = 'none';
                logoutBtn.style.display = 'none';
                loginBtn.style.display = '';
                registerBtn.style.display = '';
                usernameInput.style.display = '';
                passwordInput.style.display = '';
            }
        }

        document.getElementById('btn-register').addEventListener('click', async ()=>{
            const username = document.getElementById('auth-username').value.trim();
            const password = document.getElementById('auth-password').value;
            if(!username || !password) return alert('Enter username and password');
            try{
                const r = await fetch(API_ROOT+'/register', {
                    method: 'POST',
                    headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({ username, password })
                });
                const data = await r.json();
                if(!r.ok) return alert(data.error || 'Register failed');
                setAuthToken(data.token);
                await updateAuthUI();
            }catch(err){ alert('Register failed'); }
        });

        document.getElementById('btn-login').addEventListener('click', async ()=>{
            const username = document.getElementById('auth-username').value.trim();
            const password = document.getElementById('auth-password').value;
            if(!username || !password) return alert('Enter username and password');
            try{
                const r = await fetch(API_ROOT+'/login', {
                    method: 'POST',
                    headers: {'Content-Type':'application/json'},
                    body: JSON.stringify({ username, password })
                });
                const data = await r.json();
                if(!r.ok) return alert(data.error || 'Login failed');
                setAuthToken(data.token);
                await updateAuthUI();
            }catch(err){ alert('Login failed'); }
        });

        document.getElementById('btn-logout').addEventListener('click', ()=>{
            setAuthToken(null);
            updateAuthUI();
        });

        // initialize auth UI on load
        window.addEventListener('load', ()=>{ updateAuthUI(); });
    </script>
</body>
</html> `